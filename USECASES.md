PubSub use cases
================

> Compilation of possible uses for PubSub. These are (should) be accompained by a description, requirements and expected API.

# Collaborative Platforms (chat, editors, live streaming)

### Description

### Examples

  - chat / communication systems
  - collaborative editors
  - live streaming

### Requirements

- PubSub type: topic based
- Javascript library preferred
- message could be a <hash> too
- latency: delivery in < 1ms ;)
- needs to be push (on subscriber side)
- topology: ideally all-to-all (distributed), would be ok with many-to-all (decentralized)
- links: redis has a solid interface (https://www.npmjs.com/package/redis#publish--subscribe)

### Interface

- ipfs.sub('topic', (sender, message) => ...)
  - `topic`  can include wildcards: `topic-from-haad-*`
- ipfs.publish('topic', message)



# Collaborative News Feeds/Boards (Reddit, News sites and so on)

### Description

### Examples

### Requirements

- topology: some-to-many
- type: topic, content, type, concept (can be any)  // type and content - subscription represented as a query, reuse IPLD with predicates, inspiration from XPATH pub-sub ??
- reliability: does not need to be a requirement //reliability/correctness related properties:- delivery guarantees, enforce ordering, allow gaps.
- realtime: not 100% required  // efficiency-related properties:- timeliness, limitation of rate/period/length/size of infromation received
- encryption: important
- interface:
  - subscriber:
      - Be able to subscribe on one or more topics and validate that each message was generated by a trusted source  // regular expressions over topic space, "content-based" condition/predicates on each level of namespace  -- generic content-based queries/subscriptions over the real inner content require some kind of prior agreement on format (simpe text, XML ?, JSON, etc., lots of inspiration for the interfaces can be derived from XML/XPATH - though actually very inefficient.
      - Subscribe and validate all the updates through the PubKey found in the IPRS record (https://github.com/ipfs/specs/tree/master/iprs-interplanetary-record-system)
      - `pubsub subscribe --{topic, content, type, concept}="[...]" --auth=/iprs/QmHash`
      - publisher:
        - Be able to join a 'ring of publishers'
        - Publish under a key or several keys
  - Simple example:
    - Wordpress webpage   // subscribe to all updates in setion / page / set of pages; subscribe to updates by person / set of people, to updates with given content (string) or specific update metadata iinformation 
    - Have several roles (Author/Editor/Subscriber), organize the network based on these roles (e.g Author link to Editor and subscribers, subscribers to subscribers)
    - Converge the news feeds through CRDT (offload that responsability from the pubsub protocol)
      // stock ticker based on topic (market / stock domain / companu names), based on content (e.g., variation over X% )
      // betting system warning system based on domain / competition / team, etc. and based on content (odds over X, odds raising over X%, etc.)

### Interface

# Listening on IPNS updates

### Description

I want to be able to get updates on the new hash that an IPNS key is signing,

### App examples

### Requirements

  When there is a new update (that invalidate the previous one) and the owner signs it,
  The owner should be able to propagate the update to the rest of the network
  Even if the owner does not propagate to the rest, if users fetch it and they have subscribers, they should be able to propagate it
- Properties:
  1. Can skip messages (unreliable)
  2. No need of ordering (only the latest one really counts!)
    - Q: which one is the latest though? (causal ordering!? to be defined)
  3. Little flooding through the network
  4. Does not need to persist beyond IPNS expiration time
  5. On new messages, we can just skip gossiping/emitting the previous ones
- In essence: replaces the DHT via a lazy pub/sub, you only get updates when peers connected to you receive an IPNS update

### Interface
- API:
  - Subscriber
    - .sub(HASH) (we could actually make this hierarchical with IPLD pathing HASH/friends/0/blog)
    - .unsub(HASH)
  - Publisher
    - .pub(HASH, content) (no need to re-publish for all the hierarchical changes since .pub should be clever enough)


# Virtual reality (games)

### Description

Creat shared multiplayer environments, potentially thousands of users.
Similar requirements to chat, but events are more frequent and smaller

* Interface: Library
* Ideally something that works in JavaScript/browser via WebRTC
* Pushx
* Persistent (maybe?)
* Low latency
* Ability to prioritize events (some inputs can be discarded, user knows priority)
* Complex filtering (users only need to track events based on their location)
* Ordering of events can be causal

### Examples

### Requirements

### Interface


# Analyitcs service

### Description

- Subsystem that listens to messages sent from a cluster of nodes pertaining to particular types of events or metrics. Has some ability to alert based on particular thresholds for a metric. Displays graphs/visualizations.

### Examples

### Requirements

### Interface
-Ideal interface:
  - func publish(topic, message) error
  - func read(topic) (message, error)
Properties:
1. Persistant queues of messages per topic, but of bounded length if no reads occur, futher older messages may be cleared.
2. Effortless topic creation (there's no create topic or other topic management on the publisher side)
